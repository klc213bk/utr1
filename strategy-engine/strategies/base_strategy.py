"""
Base Strategy Interface

All trading strategies must inherit from BaseStrategy and implement its abstract methods.
This ensures a consistent interface across all strategies and makes them compatible
with the Strategy Engine.
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum


class SignalType(Enum):
    """Types of trading signals"""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"


@dataclass
class Signal:
    """
    Trading signal generated by a strategy

    Attributes:
        strategy_id: Unique identifier for the strategy instance
        strategy_type: Name of the strategy (e.g., 'ma_cross', 'rsi')
        action: BUY, SELL, or HOLD
        symbol: Trading symbol (e.g., 'SPY')
        quantity: Number of shares to trade
        timestamp: Time of signal generation
        price: Current price at signal generation
        confidence: Optional confidence level (0-1)
        metadata: Additional strategy-specific data
    """
    strategy_id: str
    strategy_type: str
    action: SignalType
    symbol: str
    quantity: int
    timestamp: str
    price: float
    confidence: float = 1.0
    metadata: Dict[str, Any] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary for JSON serialization"""
        result = {
            "strategy_id": self.strategy_id,
            "strategy_type": self.strategy_type,
            "action": self.action.value,
            "symbol": self.symbol,
            "quantity": self.quantity,
            "timestamp": self.timestamp,
            "price": self.price,
            "confidence": self.confidence
        }
        if self.metadata:
            result.update(self.metadata)
        return result


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies

    To create a new strategy:
    1. Inherit from BaseStrategy
    2. Implement all abstract methods
    3. Define strategy_name and default_params
    4. Add your strategy logic

    Example:
        class MyStrategy(BaseStrategy):
            strategy_name = "my_strategy"
            default_params = {"threshold": 0.5}

            def initialize(self, strategy_id: str, params: Dict[str, Any]):
                super().initialize(strategy_id, params)
                self.threshold = self.params.get("threshold", 0.5)

            def process_bar(self, bar: Dict[str, Any]) -> Optional[Signal]:
                # Your logic here
                return None
    """

    # Subclasses must define these
    strategy_name: str = None
    default_params: Dict[str, Any] = {}

    def __init__(self):
        """Initialize strategy base"""
        self.strategy_id: Optional[str] = None
        self.params: Dict[str, Any] = {}
        self.state: Dict[str, Any] = {}
        self.bars_history: List[float] = []
        self.max_history_size: int = 100

        if self.strategy_name is None:
            raise NotImplementedError(
                f"{self.__class__.__name__} must define 'strategy_name' class attribute"
            )

    def initialize(self, strategy_id: str, params: Dict[str, Any]):
        """
        Initialize strategy instance with specific parameters

        Args:
            strategy_id: Unique identifier for this strategy instance
            params: Strategy-specific parameters (merged with defaults)
        """
        self.strategy_id = strategy_id
        # Merge provided params with defaults
        self.params = {**self.default_params, **params}
        self.state = {}
        self.bars_history = []

        print(f"âœ… Initialized {self.strategy_name} (ID: {strategy_id}) with params: {self.params}")

    @abstractmethod
    def process_bar(self, bar: Dict[str, Any]) -> Optional[Signal]:
        """
        Process a single price bar and optionally generate a trading signal

        This is the main method called for each new bar of data. Implement your
        strategy logic here.

        Args:
            bar: Dictionary containing bar data with keys:
                - time: Timestamp
                - open: Opening price
                - high: High price
                - low: Low price
                - close: Closing price
                - volume: Volume

        Returns:
            Signal object if a trade should be made, None otherwise
        """
        pass

    def update_history(self, close_price: float):
        """
        Update price history (helper method)

        Args:
            close_price: Current closing price
        """
        self.bars_history.append(close_price)
        if len(self.bars_history) > self.max_history_size:
            self.bars_history.pop(0)

    def get_sma(self, period: int) -> Optional[float]:
        """
        Calculate Simple Moving Average (helper method)

        Args:
            period: Number of bars for SMA calculation

        Returns:
            SMA value if enough history, None otherwise
        """
        if len(self.bars_history) < period:
            return None
        return sum(self.bars_history[-period:]) / period

    def get_ema(self, period: int, smoothing: float = 2.0) -> Optional[float]:
        """
        Calculate Exponential Moving Average (helper method)

        Args:
            period: Number of bars for EMA calculation
            smoothing: Smoothing factor (default 2.0)

        Returns:
            EMA value if enough history, None otherwise
        """
        if len(self.bars_history) < period:
            return None

        prices = self.bars_history[-period:]
        multiplier = smoothing / (period + 1)
        ema = prices[0]

        for price in prices[1:]:
            ema = (price * multiplier) + (ema * (1 - multiplier))

        return ema

    def get_rsi(self, period: int = 14) -> Optional[float]:
        """
        Calculate Relative Strength Index (helper method)

        Args:
            period: Number of bars for RSI calculation (default 14)

        Returns:
            RSI value if enough history, None otherwise
        """
        if len(self.bars_history) < period + 1:
            return None

        prices = self.bars_history[-(period + 1):]
        gains = []
        losses = []

        for i in range(1, len(prices)):
            change = prices[i] - prices[i-1]
            if change > 0:
                gains.append(change)
                losses.append(0)
            else:
                gains.append(0)
                losses.append(abs(change))

        avg_gain = sum(gains) / period
        avg_loss = sum(losses) / period

        if avg_loss == 0:
            return 100.0

        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))

        return rsi

    def create_signal(
        self,
        action: SignalType,
        bar: Dict[str, Any],
        quantity: int = 100,
        confidence: float = 1.0,
        **metadata
    ) -> Signal:
        """
        Create a trading signal (helper method)

        Args:
            action: BUY, SELL, or HOLD
            bar: Current bar data
            quantity: Number of shares (default 100)
            confidence: Signal confidence 0-1 (default 1.0)
            **metadata: Additional strategy-specific data

        Returns:
            Signal object ready to publish
        """
        symbol = self.params.get("symbol", "SPY")

        return Signal(
            strategy_id=self.strategy_id,
            strategy_type=self.strategy_name,
            action=action,
            symbol=symbol,
            quantity=quantity,
            timestamp=bar.get("time", ""),
            price=float(bar.get("close", 0)),
            confidence=confidence,
            metadata=metadata
        )

    def on_start(self):
        """
        Called when strategy starts (optional override)

        Use this for any initialization that needs to happen
        before processing bars.
        """
        pass

    def on_stop(self):
        """
        Called when strategy stops (optional override)

        Use this for cleanup or final calculations.
        """
        pass

    def get_state(self) -> Dict[str, Any]:
        """
        Get current strategy state for debugging/monitoring

        Returns:
            Dictionary of current state
        """
        return {
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "params": self.params,
            "bars_collected": len(self.bars_history),
            "state": self.state
        }

    def __repr__(self) -> str:
        return f"{self.strategy_name}(id={self.strategy_id})"
